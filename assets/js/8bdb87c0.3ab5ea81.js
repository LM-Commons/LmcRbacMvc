"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5317],{8773:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var i=t(4848),o=t(8453);const s={sidebar_position:8},r="Cookbook",c={id:"cookbook",title:"Cookbook",description:"This section will help you further understand how LmcRbacMvc works by providing more concrete examples. If you have",source:"@site/versioned_docs/version-3.4/cookbook.md",sourceDirName:".",slug:"/cookbook",permalink:"/LmcRbacMvc/docs/cookbook",draft:!1,unlisted:!1,editUrl:"https://github.com/lm-commons/lmcrbacmvc/tree/master/docs/versioned_docs/version-3.4/cookbook.md",tags:[],version:"3.4",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"Using the Authorization Service",permalink:"/LmcRbacMvc/docs/using-the-authorization-service"},next:{title:"Support",permalink:"/LmcRbacMvc/docs/support"}},a={},l=[{value:"A Real World Application",id:"a-real-world-application",level:2},{value:"Best practices",id:"best-practices",level:2},{value:"When using guards then?",id:"when-using-guards-then",level:3},{value:"A Real World Application Part 2 - Only delete your own Posts",id:"a-real-world-application-part-2---only-delete-your-own-posts",level:2},{value:"A Real World Application Part 3 - Admins can delete everything",id:"a-real-world-application-part-3---admins-can-delete-everything",level:2},{value:"A Real World Application Part 4 - Checking permissions in the view",id:"a-real-world-application-part-4---checking-permissions-in-the-view",level:2},{value:"Using LmcRbacMvc with Doctrine ORM",id:"using-lmcrbacmvc-with-doctrine-orm",level:2},{value:"How to deal with roles with lot of permissions?",id:"how-to-deal-with-roles-with-lot-of-permissions",level:2},{value:"Using LmcRbacMvc and ZF2 Assetic",id:"using-lmcrbacmvc-and-zf2-assetic",level:2},{value:"Using LmcRbacMvc and LmcUser",id:"using-lmcrbacmvc-and-lmcuser",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"cookbook",children:"Cookbook"})}),"\n",(0,i.jsx)(n.p,{children:"This section will help you further understand how LmcRbacMvc works by providing more concrete examples. If you have\nany other recipe you'd like to add, please open an issue!"}),"\n",(0,i.jsx)(n.h2,{id:"a-real-world-application",children:"A Real World Application"}),"\n",(0,i.jsxs)(n.p,{children:["In this example we are going to create a very little real world application. We will create a controller\n",(0,i.jsx)(n.code,{children:"PostController"})," that interacts with a service called ",(0,i.jsx)(n.code,{children:"PostService"}),". For the sake of simplicity we will only\ncover the ",(0,i.jsx)(n.code,{children:"delete"}),"-methods of both parts."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's start by creating a controller that has the ",(0,i.jsx)(n.code,{children:"PostService"})," as dependency:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class PostController\n{\n    protected $postService;\n\n    public function __construct(PostService $postService)\n    {\n        $this->postService = $postService;\n    }\n\n    // addAction(), editAction(), etc...\n\n    public function deleteAction()\n    {\n        $id = $this->params()->fromQuery('id');\n\n        $this->postService->deletePost($id);\n\n        return $this->redirect()->toRoute('posts');\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since we have a dependency, let's inject it using the ",(0,i.jsx)(n.code,{children:"ControllerManager"}),", we will do this inside our ",(0,i.jsx)(n.code,{children:"Module"})," class"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class Module\n{\n    public function getConfig()\n    {\n        return [\n            'controllers' => [\n                'factories' => [\n                    'PostController' => function ($cpm) {\n                        // We assume a Service key 'PostService' here that returns the PostService Class\n                        return new PostController(\n                            $cpm->getServiceLocator()->get('PostService')\n                        );\n                    },\n                ],\n            ],\n        ];\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have this in place let us quickly define our ",(0,i.jsx)(n.code,{children:"PostService"}),". We will be using a Service that makes use\nof Doctrine, so we require a ",(0,i.jsx)(n.code,{children:"Doctrine\\Persistence\\ObjectManager"})," as dependency."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Persistence\\ObjectManager;\n\nclass PostService\n{\n    protected $objectManager;\n\n    public function __construct(ObjectManager $objectManager)\n    {\n        $this->objectManager = $objectManager;\n    }\n\n    public function deletePost($id)\n    {\n        $post = $this->objectManager->find('Post', $id);\n        $this->objectManager->remove($post);\n        $this->objectManager->flush();\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And for this one, too, let's quickly create the factory, again within our ",(0,i.jsx)(n.code,{children:"Module"})," class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class Module\n{\n    // getAutoloaderConfig(), getConfig(), etc...\n\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                 'PostService' => function($sm) {\n                     return new PostService(\n                         $sm->get('doctrine.entitymanager.orm_default')\n                     );\n                 }\n            ]\n        ];\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"With this set up we can now cover some best practices."}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best practices"}),"\n",(0,i.jsx)(n.p,{children:"Ideally, you should not protect your applications using only guards (Route or Controller guards).\nThis leaves your application open for some undesired side-effects.\nAs a best practice you should protect all your services or controllers by injecting the authorization service.\nBut let's go step by step:"}),"\n",(0,i.jsx)(n.p,{children:"Assuming the application example above we can easily use LmcRbacMvc to protect our route using the following guard:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'lmc_rbac' => [\n        'guards' => [\n            'LmcRbacMvc\\Guard\\RouteGuard' => [\n                'post/delete' => ['admin']\n            ]\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsx)(n.p,{children:'Now, any users that do not have the "admin" role will receive a 403 error (unauthorized) when trying to access\nthe "post/delete" route. However, this does not prevent the service (which should contain the actual logic in a properly\ndesign application) to be injected and used elsewhere in your code. For instance:'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class PostController\n{\n    protected $postService;\n\n    public function createAction()\n    {\n        // this action may have been reached through the \"forward\" method, hence bypassing guards\n        $this->postService->deletePost('2');\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"You see the issue!"}),"\n",(0,i.jsxs)(n.p,{children:["The solution is to inject the ",(0,i.jsx)(n.code,{children:"AuthorizationService"})," into your services and check for the\npermissions before doing anything wrong. So let's modify our previously created ",(0,i.jsx)(n.code,{children:"PostService"})," class"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Persistence\\ObjectManager;\nuse LmcRbacMvc\\Service\\AuthorizationService;\n\nclass PostService\n{\n    protected $objectManager;\n\n    protected $authorizationService;\n\n    public function __construct(\n        ObjectManager        $objectManager,\n        AuthorizationService $autorizationService\n    ) {\n        $this->objectManager        = $objectManager;\n        $this->authorizationService = $autorizationService;\n    }\n\n    public function deletePost($id)\n    {\n        // First check permission\n        if (!$this->authorizationService->isGranted('deletePost')) {\n            throw new UnauthorizedException('You are not allowed !');\n        }\n\n        $post = $this->objectManager->find('Post', $id);\n        $this->objectManager->remove($post);\n        $this->objectManager->flush();\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Since we now have an additional dependency we should inject it through our factory, again within our ",(0,i.jsx)(n.code,{children:"Module"})," class."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class Module\n{\n    // getAutoloaderConfig(), getConfig(), etc...\n\n    public function getServiceConfig()\n    {\n        return [\n            'factories' => [\n                 'PostService' => function($sm) {\n                     return new PostService(\n                         $sm->get('doctrine.entitymanager.orm_default'),\n                         $sm->get('LmcRbacMvc\\Service\\AuthorizationService') // This is new!\n                     );\n                 }\n            ]\n        ];\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Alternatively, you can also protect your controllers using the ",(0,i.jsx)(n.code,{children:"isGranted"})," helper (you do not need to inject\nthe AuthorizationService then):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"class PostController\n{\n    protected $postService;\n\n    public function createAction()\n    {\n        if (!$this->isGranted('deletePost')) {\n            throw new UnauthorizedException('You are not allowed !');\n        }\n\n        $this->postService->deletePost('2');\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"While protecting services is the more defensive way (because services are usually the last part of the logic flow),\nit is often complicated to deal with.\nIf your application is architectured correctly, it is often simpler to protect your controllers."}),"\n",(0,i.jsx)(n.h3,{id:"when-using-guards-then",children:"When using guards then?"}),"\n",(0,i.jsx)(n.p,{children:"In fact, you should see guards as a very efficient way to quickly reject access to a hierarchy of routes or a\nwhole controller. For instance, assuming you have the following route config:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'router' => [\n        'routes' => [\n            'admin' => [\n                'type'    => 'Literal',\n                'options' => [\n                    'route' => '/admin'\n                ],\n                'may_terminate' => true,\n                'child_routes' => [\n                    'users' => [\n                        'type' => 'Literal',\n                        'options' => [\n                            'route' => '/users'\n                        ]\n                    ],\n                    'invoices' => [\n                        'type' => 'Literal',\n                        'options' => [\n                            'route' => '/invoices'\n                        ]\n                    ]\n                ]\n            ]\n        ]\n    ]\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can quickly reject access to all admin routes using the following guard:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'lmc_rbac' => [\n        'guards' => [\n            'LmcRbacMvc\\Guard\\RouteGuard' => [\n                'admin*' => ['admin']\n            ]\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsx)(n.h2,{id:"a-real-world-application-part-2---only-delete-your-own-posts",children:"A Real World Application Part 2 - Only delete your own Posts"}),"\n",(0,i.jsxs)(n.p,{children:["If you jumped straight to this section please notice that we assume you have the knowledge that we presented in the\nprevious example. In here we will cover a very common use case. Users of our Application should only have delete\npermissions to their own content. So let's quickly refresh our ",(0,i.jsx)(n.code,{children:"PostService"})," class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Persistence\\ObjectManager;\n\nclass PostService\n{\n    protected $objectManager;\n\n    protected $authorizationService;\n\n    public function __construct(\n        ObjectManager        $objectManager,\n        AuthorizationService $autorizationService\n    ) {\n        $this->objectManager        = $objectManager;\n        $this->authorizationService = $autorizationService;\n    }\n\n    public function deletePost($id)\n    {\n        // First check permission\n        if (!$this->authorizationService->isGranted('deletePost')) {\n            throw new UnauthorizedException('You are not allowed !');\n        }\n\n        $post = $this->objectManager->find('Post', $id);\n        $this->objectManager->remove($post);\n        $this->objectManager->flush();\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As we can see, we check within our Service if the User of our Application is allowed to delete the post with a check\nagainst the ",(0,i.jsx)(n.code,{children:"deletePost"})," permission. Now how can we achieve that only a user who is the owner of the Post to be able to\ndelete his own post, but other users can't? We do not want to change our Service with more complex logic because this\nis not the task of such service. The Permission-System should handle this. And we can, for this we have the\n",(0,i.jsx)(n.code,{children:"AssertionPluginManager"})," and here is how to do it:"]}),"\n",(0,i.jsx)(n.p,{children:"First of all we need to write an Assertion. The Assertion will return a boolean statement about the current\nidentity being the owner of the post."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"namespace Your\\Namespace;\n\nuse LmcRbacMvc\\Assertion\\AssertionInterface;\nuse LmcRbacMvc\\Service\\AuthorizationService;\n\nclass MustBeAuthorAssertion implements AssertionInterface\n{\n    /**\n     * Check if this assertion is true\n     *\n     * @param  AuthorizationService $authorization\n     * @param  mixed                $post\n     *\n     * @return bool\n     */\n    public function assert(AuthorizationService $authorization, $post = null)\n    {\n        return $authorization->getIdentity() === $post->getAuthor();\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This simple ",(0,i.jsx)(n.code,{children:"MustBeAuthorAssertion"})," will check against the current ",(0,i.jsx)(n.code,{children:"$authorization"}),' if it equals the identity of the\ncurrent context Author. The second parameter is called the "context". A context can be anything (an object, a scalar,\nan array...) and only makes sense in the context of the assertion.']}),"\n",(0,i.jsxs)(n.p,{children:["Imagine a user calls ",(0,i.jsx)(n.code,{children:"http://my.dom/post/delete/42"}),", so obviously he wants to delete the Post-Entity with ID#42. In\nthis case Entity#42 is our Context! If you're wondering how the context gets there, bare with me. We will get to\nthis later."]}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have written the Assertion, we want to make sure that this assertion will always be called, whenever we\ncheck for the ",(0,i.jsx)(n.code,{children:"deletePost"})," permission. We don't want others to delete our previous content! For this we have the so\ncalled ",(0,i.jsx)(n.code,{children:"assertion_map"}),". In this map we glue ",(0,i.jsx)(n.code,{children:"assertions"})," and ",(0,i.jsx)(n.code,{children:"permissions"})," together."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// config/autoload/lmc_rbac.global.php or wherever your LmcRbac configuration file is\nreturn [\n    'lmc_rbac' => [\n        'assertion_map' => [\n            'deletePost' => 'Your\\Namespace\\MustBeAuthorAssertion'\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, whenever some test the ",(0,i.jsx)(n.code,{children:"deletePost"})," permission, it will automatically call the ",(0,i.jsx)(n.code,{children:"MustBeAuthorAssertion"})," from\nthe ",(0,i.jsx)(n.code,{children:"AssertionPluginManager"}),". This plugin manager is configured to automatically add unknown classes to an invokable.\nHowever, some assertions may need dependencies. You can manually configure the assertion plugin manager as\nshown below:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// config/autoload/lmc_rbac.global.php or wherever your LmcRbac configuration file is\nreturn [\n    'lmc_rbac' => [\n        // ... other rbac stuff\n        'assertion_manager' => [\n            'factories' => [\n                'AssertionWithDependency' => 'Your\\Namespace\\AssertionWithDependencyFactory'\n            ]\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now we need to remember about the ",(0,i.jsx)(n.strong,{children:"context"}),". Somehow we need to let the ",(0,i.jsx)(n.code,{children:"AssertionPluginManager"})," know about our\ncontext. This is done by simply passing it to the ",(0,i.jsx)(n.code,{children:"isGranted()"})," method. For this we need to modify our Service\none last time."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Persistence\\ObjectManager;\n\nclass PostService\n{\n    protected $objectManager;\n\n    protected $authorizationService;\n\n    public function __construct(\n        ObjectManager        $objectManager,\n        AuthorizationService $autorizationService\n    ) {\n        $this->objectManager        = $objectManager;\n        $this->authorizationService = $autorizationService;\n    }\n\n    public function deletePost($id)\n    {\n        // Note, we now need to query for the post of interest first!\n        $post = $this->objectManager->find('Post', $id);\n\n        // Check the permission now with a given context\n        if (!$this->authorizationService->isGranted('deletePost', $post)) {\n            throw new UnauthorizedException('You are not allowed !');\n        }\n\n        $this->objectManager->remove($post);\n        $this->objectManager->flush();\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And there you have it. The context is injected into the ",(0,i.jsx)(n.code,{children:"isGranted()"})," method and now the ",(0,i.jsx)(n.code,{children:"AssertionPluginManager"})," knows\nabout it and can do its thing. Note that in reality, after you have queried for the ",(0,i.jsx)(n.code,{children:"$post"})," you would check if ",(0,i.jsx)(n.code,{children:"$post"}),"\nis actually a real post. Because if it is an empty return value then you should throw an exception earlier without\nneeding to check against the permission."]}),"\n",(0,i.jsx)(n.h2,{id:"a-real-world-application-part-3---admins-can-delete-everything",children:"A Real World Application Part 3 - Admins can delete everything"}),"\n",(0,i.jsx)(n.p,{children:"Often, you want users with a specific role to be able to have full access to everything. For instance, admins could\ndelete all the posts, even if they don't own it."}),"\n",(0,i.jsxs)(n.p,{children:["However, with the previous assertion, even if the admin has the permission ",(0,i.jsx)(n.code,{children:"deletePost"}),", it won't work because\nthe assertion will evaluate to false."]}),"\n",(0,i.jsxs)(n.p,{children:["Actually, the answer is quite simple: deleting my own posts and deleting others' posts should be treated like\ntwo different permissions (it makes sense if you think about it). Therefore, admins will have the permission\n",(0,i.jsx)(n.code,{children:"deleteOthersPost"})," (as well as the permission ",(0,i.jsx)(n.code,{children:"deletePost"}),", because admin could write posts, too)."]}),"\n",(0,i.jsx)(n.p,{children:"The assertion must therefore be modified like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"namespace Your\\Namespace;\n\nuse LmcRbacMvc\\Assertion\\AssertionInterface;\nuse LmcRbacMvc\\Service\\AuthorizationService;\n\nclass MustBeAuthorAssertion implements AssertionInterface\n{\n    /**\n     * Check if this assertion is true\n     *\n     * @param  AuthorizationService $authorization\n     * @param  mixed                $context\n     *\n     * @return bool\n     */\n    public function assert(AuthorizationService $authorization, $context = null)\n    {\n        if ($authorization->getIdentity() === $context->getAuthor()) {\n            return true;\n        }\n\n        return $authorization->isGranted('deleteOthersPost');\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"a-real-world-application-part-4---checking-permissions-in-the-view",children:"A Real World Application Part 4 - Checking permissions in the view"}),"\n",(0,i.jsxs)(n.p,{children:["If some part of the view needs to be protected, you can use the shipped ",(0,i.jsx)(n.code,{children:"isGranted"})," view helper."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, lets's say that only users with the permissions ",(0,i.jsx)(n.code,{children:"post.manage"})," will have a menu item to acces\nthe adminsitration panel :"]}),"\n",(0,i.jsx)(n.p,{children:"In your template post-index.phtml"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'<ul class="nav">\n    <li><a href="/">Home</a></li>\n    <li><a href="/posts/list">View posts</a></li>\n    <?php if ($this->isGranted(\'post.manage\'): ?>\n    <li><a href="/posts/admin">Manage posts</a></li>\n    <?php endif ?>\n</ul>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["You can even protect your menu item regarding a role, by using the ",(0,i.jsx)(n.code,{children:"hasRole"})," view helper :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'<ul class="nav">\n    <li><a href="/">Home</a></li>\n    <li><a href="/posts/list">View posts</a></li>\n    <?php if ($this->hasRole(\'admin\'): ?>\n    <li><a href="/posts/admin">Manage posts</a></li>\n    <?php endif ?>\n</ul>\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this last example, the menu item will be hidden for users who don't have the ",(0,i.jsx)(n.code,{children:"admin"})," role."]}),"\n",(0,i.jsx)(n.h2,{id:"using-lmcrbacmvc-with-doctrine-orm",children:"Using LmcRbacMvc with Doctrine ORM"}),"\n",(0,i.jsxs)(n.p,{children:["First your User entity class must implement ",(0,i.jsx)(n.code,{children:"LmcRbacMvc\\Identity\\IdentityInterface"})," :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'use LmccUser\\Entity\\User as LmcUserEntity;\nuse LmcRbacMvc\\Identity\\IdentityInterface;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Doctrine\\Common\\Collections\\ArrayCollection;\nuse Doctrine\\Common\\Collections\\Collection;\n\n/**\n * @ORM\\Entity\n * @ORM\\Table(name="user")\n */\nclass User extends LmcUserEntity implements IdentityInterface\n{\n    /**\n     * @var Collection\n     * @ORM\\ManyToMany(targetEntity="HierarchicalRole")\n     */\n    private $roles;\n\n    public function __construct()\n    {\n        $this->roles = new ArrayCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getRoles()\n    {\n        return $this->roles->toArray();\n    }\n\n    /**\n     * Set the list of roles\n     * @param Collection $roles\n     */\n    public function setRoles(Collection $roles)\n    {\n        $this->roles->clear();\n        foreach ($roles as $role) {\n            $this->roles[] = $role;\n        }\n    }\n\n    /**\n     * Add one role to roles list\n     * @param \\Rbac\\Role\\RoleInterface $role\n     */\n    public function addRole(RoleInterface $role)\n    {\n        $this->roles[] = $role;\n    }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["For this example we will use a more complex situation by using ",(0,i.jsx)(n.code,{children:"Rbac\\Role\\HierarchicalRoleInterface"})," so the second step is to create HierarchicalRole entity class"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'class HierarchicalRole implements HierarchicalRoleInterface\n{\n    /**\n     * @var HierarchicalRoleInterface[]|\\Doctrine\\Common\\Collections\\Collection\n     *\n     * @ORM\\ManyToMany(targetEntity="HierarchicalRole")\n     */\n    protected $children;\n\n    /**\n     * @var PermissionInterface[]|\\Doctrine\\Common\\Collections\\Collection\n     *\n     * @ORM\\ManyToMany(targetEntity="Permission", indexBy="name", fetch="EAGER", cascade={"persist"})\n     */\n    protected $permissions;\n\n    /**\n     * Init the Doctrine collection\n     */\n    public function __construct()\n    {\n        $this->children    = new ArrayCollection();\n        $this->permissions = new ArrayCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function addChild(HierarchicalRoleInterface $child)\n    {\n        $this->children[] = $child;\n    }\n\n    /*\n     * Set the list of permission\n     * @param Collection $permissions\n     */\n    public function setPermissions(Collection $permissions)\n    {\n        $this->permissions->clear();\n        foreach ($permissions as $permission) {\n            $this->permissions[] = $permission;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function addPermission($permission)\n    {\n        if (is_string($permission)) {\n            $permission = new Permission($permission);\n        }\n\n        $this->permissions[(string) $permission] = $permission;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function hasPermission($permission)\n    {\n        // This can be a performance problem if your role has a lot of permissions. Please refer\n        // to the cookbook to an elegant way to solve this issue\n\n        return isset($this->permissions[(string) $permission]);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function getChildren()\n    {\n        return $this->children->toArray();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function hasChildren()\n    {\n        return !$this->children->isEmpty();\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"And the last step is to create a Permission entity class which is a very simple entity class. You don't have to do specific things!"}),"\n",(0,i.jsxs)(n.p,{children:["You can find all entity examples in this folder : ",(0,i.jsx)(n.a,{href:"https://github.com/LM-Commons/LmcRbacMvc/tree/master/data",children:"Example"})]}),"\n",(0,i.jsxs)(n.p,{children:["You need one more configuration step. Indeed, how can the RoleProvider retrieve your role and permissions? For this you need to configure ",(0,i.jsx)(n.code,{children:"LmcRbacMvc\\Role\\ObjectRepositoryRoleProvider"})," in your ",(0,i.jsx)(n.code,{children:"lmc_rbac.global.php"})," file :"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"        /**\n         * Configuration for role provider\n         */\n        'role_provider' => [\n            'LmcRbacMvc\\Role\\ObjectRepositoryRoleProvider' => [\n                'object_manager'     => 'doctrine.entitymanager.orm_default', // alias for doctrine ObjectManager\n                'class_name'         => 'User\\Entity\\HierarchicalRole', // FQCN for your role entity class\n                'role_name_property' => 'name', // Name to show\n            ],\n        ],\n"})}),"\n",(0,i.jsx)(n.p,{children:"Using DoctrineORM with LmcRbacMvc is very simple. You need to be aware of performance where there is a lot of permissions for roles."}),"\n",(0,i.jsx)(n.h2,{id:"how-to-deal-with-roles-with-lot-of-permissions",children:"How to deal with roles with lot of permissions?"}),"\n",(0,i.jsxs)(n.p,{children:["In very complex applications, your roles may have dozens of permissions. In the [/data/FlatRole.php.dist] entity\nwe provide, we configure the permissions association so that whenever a role is loaded, all of its permissions are also\nloaded in one query (notice the ",(0,i.jsx)(n.code,{children:'fetch="EAGER"'}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'/**\n  * @ORM\\ManyToMany(targetEntity="Permission", indexBy="name", fetch="EAGER")\n  */\nprotected $permissions;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"hasPermission"})," method is therefore really simple:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"public function hasPermission($permission)\n{\n    return isset($this->permissions[(string) $permission]);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, with a lot of permissions, this method will quickly kill your database. What you can do is modfiy the Doctrine\nmapping so that the collection is not actually loaded:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:'/**\n  * @ORM\\ManyToMany(targetEntity="Permission", indexBy="name", fetch="LAZY")\n  */\nprotected $permissions;\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Then, modify the ",(0,i.jsx)(n.code,{children:"hasPermission"})," method to use the Criteria API. The Criteria API is a Doctrine 2.2+ API that allows\nyour application to efficiently filter a collection without loading the whole collection:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Criteria;\n\npublic function hasPermission($permission)\n{\n    $criteria = Criteria::create()->where(Criteria::expr()->eq('name', (string) $permission));\n    $result   = $this->permissions->matching($criteria);\n\n    return count($result) > 0;\n}\n"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"NOTE: This is only supported starting from Doctrine ORM 2.5!"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"using-lmcrbacmvc-and-zf2-assetic",children:"Using LmcRbacMvc and ZF2 Assetic"}),"\n",(0,i.jsxs)(n.p,{children:["To use ",(0,i.jsx)(n.a,{href:"https://github.com/widmogrod/zf2-assetic-module",children:"Assetic"})," with LmcRbacMvc guards, you should modify your\n",(0,i.jsx)(n.code,{children:"module.config.php"})," using the following configuration:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'assetic_configuration' => [\n        'acceptableErrors' => [\n            \\LmcRbacMvc\\Guard\\GuardInterface::GUARD_UNAUTHORIZED\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsx)(n.h2,{id:"using-lmcrbacmvc-and-lmcuser",children:"Using LmcRbacMvc and LmcUser"}),"\n",(0,i.jsx)(n.p,{children:"To use the authentication service from LmcUser, just add the following alias in your application.config.php:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'service_manager' => [\n        'aliases' => [\n            'Laminas\\Authentication\\AuthenticationService' => 'lmcuser_auth_service'\n        ]\n    ]\n];\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Finally add the LmcUser routes to your ",(0,i.jsx)(n.code,{children:"guards"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"return [\n    'lmc_rbac' => [\n        'guards' => [\n            'LmcRbac\\Guard\\RouteGuard' => [\n                'lmcuser/login'    => ['guest'],\n                'lmcuser/register' => ['guest'], // required if registration is enabled\n                'lmcuser*'         => ['user'] // includes logout, changepassword and changeemail\n            ]\n        ]\n    ]\n];\n"})})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var i=t(6540);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);